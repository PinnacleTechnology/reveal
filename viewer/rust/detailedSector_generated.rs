// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod detailed_sector {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

pub enum TriangleMeshOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TriangleMesh<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TriangleMesh<'a> {
    type Inner = TriangleMesh<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TriangleMesh<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TriangleMesh {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TriangleMeshArgs<'args>) -> flatbuffers::WIPOffset<TriangleMesh<'bldr>> {
      let mut builder = TriangleMeshBuilder::new(_fbb);
      builder.add_file_id(args.file_id);
      if let Some(x) = args.colors { builder.add_colors(x); }
      if let Some(x) = args.normals { builder.add_normals(x); }
      if let Some(x) = args.vertices { builder.add_vertices(x); }
      if let Some(x) = args.tree_indices { builder.add_tree_indices(x); }
      if let Some(x) = args.indices { builder.add_indices(x); }
      builder.finish()
    }

    pub const VT_FILE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_INDICES: flatbuffers::VOffsetT = 6;
    pub const VT_TREE_INDICES: flatbuffers::VOffsetT = 8;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 10;
    pub const VT_NORMALS: flatbuffers::VOffsetT = 12;
    pub const VT_COLORS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn file_id(&self) -> f64 {
    self._tab.get::<f64>(TriangleMesh::VT_FILE_ID, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn indices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TriangleMesh::VT_INDICES, None)
  }
  #[inline]
  pub fn tree_indices(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TriangleMesh::VT_TREE_INDICES, None)
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TriangleMesh::VT_VERTICES, None)
  }
  #[inline]
  pub fn normals(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TriangleMesh::VT_NORMALS, None)
  }
  #[inline]
  pub fn colors(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TriangleMesh::VT_COLORS, None).map(|v| v.safe_slice())
  }
}

pub struct TriangleMeshArgs<'a> {
    pub file_id: f64,
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub tree_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub normals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub colors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for TriangleMeshArgs<'a> {
    #[inline]
    fn default() -> Self {
        TriangleMeshArgs {
            file_id: 0.0,
            indices: None,
            tree_indices: None,
            vertices: None,
            normals: None,
            colors: None,
        }
    }
}
pub struct TriangleMeshBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TriangleMeshBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id(&mut self, file_id: f64) {
    self.fbb_.push_slot::<f64>(TriangleMesh::VT_FILE_ID, file_id, 0.0);
  }
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TriangleMesh::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_tree_indices(&mut self, tree_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TriangleMesh::VT_TREE_INDICES, tree_indices);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TriangleMesh::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn add_normals(&mut self, normals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TriangleMesh::VT_NORMALS, normals);
  }
  #[inline]
  pub fn add_colors(&mut self, colors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TriangleMesh::VT_COLORS, colors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TriangleMeshBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TriangleMeshBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TriangleMesh<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InstanceMeshOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InstanceMesh<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InstanceMesh<'a> {
    type Inner = InstanceMesh<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InstanceMesh<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InstanceMesh {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InstanceMeshArgs<'args>) -> flatbuffers::WIPOffset<InstanceMesh<'bldr>> {
      let mut builder = InstanceMeshBuilder::new(_fbb);
      builder.add_triangle_offset(args.triangle_offset);
      builder.add_triangle_count(args.triangle_count);
      if let Some(x) = args.tree_indices { builder.add_tree_indices(x); }
      if let Some(x) = args.instance_matrices { builder.add_instance_matrices(x); }
      if let Some(x) = args.colors { builder.add_colors(x); }
      builder.finish()
    }

    pub const VT_TRIANGLE_COUNT: flatbuffers::VOffsetT = 4;
    pub const VT_TRIANGLE_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_COLORS: flatbuffers::VOffsetT = 8;
    pub const VT_INSTANCE_MATRICES: flatbuffers::VOffsetT = 10;
    pub const VT_TREE_INDICES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn triangle_count(&self) -> f64 {
    self._tab.get::<f64>(InstanceMesh::VT_TRIANGLE_COUNT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn triangle_offset(&self) -> f64 {
    self._tab.get::<f64>(InstanceMesh::VT_TRIANGLE_OFFSET, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn colors(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InstanceMesh::VT_COLORS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn instance_matrices(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(InstanceMesh::VT_INSTANCE_MATRICES, None)
  }
  #[inline]
  pub fn tree_indices(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(InstanceMesh::VT_TREE_INDICES, None)
  }
}

pub struct InstanceMeshArgs<'a> {
    pub triangle_count: f64,
    pub triangle_offset: f64,
    pub colors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub instance_matrices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub tree_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
}
impl<'a> Default for InstanceMeshArgs<'a> {
    #[inline]
    fn default() -> Self {
        InstanceMeshArgs {
            triangle_count: 0.0,
            triangle_offset: 0.0,
            colors: None,
            instance_matrices: None,
            tree_indices: None,
        }
    }
}
pub struct InstanceMeshBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstanceMeshBuilder<'a, 'b> {
  #[inline]
  pub fn add_triangle_count(&mut self, triangle_count: f64) {
    self.fbb_.push_slot::<f64>(InstanceMesh::VT_TRIANGLE_COUNT, triangle_count, 0.0);
  }
  #[inline]
  pub fn add_triangle_offset(&mut self, triangle_offset: f64) {
    self.fbb_.push_slot::<f64>(InstanceMesh::VT_TRIANGLE_OFFSET, triangle_offset, 0.0);
  }
  #[inline]
  pub fn add_colors(&mut self, colors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMesh::VT_COLORS, colors);
  }
  #[inline]
  pub fn add_instance_matrices(&mut self, instance_matrices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMesh::VT_INSTANCE_MATRICES, instance_matrices);
  }
  #[inline]
  pub fn add_tree_indices(&mut self, tree_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMesh::VT_TREE_INDICES, tree_indices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstanceMeshBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstanceMeshBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InstanceMesh<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InstanceMeshFileOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InstanceMeshFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InstanceMeshFile<'a> {
    type Inner = InstanceMeshFile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InstanceMeshFile<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InstanceMeshFile {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InstanceMeshFileArgs<'args>) -> flatbuffers::WIPOffset<InstanceMeshFile<'bldr>> {
      let mut builder = InstanceMeshFileBuilder::new(_fbb);
      builder.add_file_id(args.file_id);
      if let Some(x) = args.instances { builder.add_instances(x); }
      if let Some(x) = args.normals { builder.add_normals(x); }
      if let Some(x) = args.vertices { builder.add_vertices(x); }
      if let Some(x) = args.indices { builder.add_indices(x); }
      builder.finish()
    }

    pub const VT_FILE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_INDICES: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 8;
    pub const VT_NORMALS: flatbuffers::VOffsetT = 10;
    pub const VT_INSTANCES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn file_id(&self) -> f64 {
    self._tab.get::<f64>(InstanceMeshFile::VT_FILE_ID, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn indices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(InstanceMeshFile::VT_INDICES, None)
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(InstanceMeshFile::VT_VERTICES, None)
  }
  #[inline]
  pub fn normals(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(InstanceMeshFile::VT_NORMALS, None)
  }
  #[inline]
  pub fn instances(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstanceMesh<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InstanceMesh<'a>>>>>(InstanceMeshFile::VT_INSTANCES, None)
  }
}

pub struct InstanceMeshFileArgs<'a> {
    pub file_id: f64,
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub normals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  f32>>>,
    pub instances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InstanceMesh<'a >>>>>,
}
impl<'a> Default for InstanceMeshFileArgs<'a> {
    #[inline]
    fn default() -> Self {
        InstanceMeshFileArgs {
            file_id: 0.0,
            indices: None,
            vertices: None,
            normals: None,
            instances: None,
        }
    }
}
pub struct InstanceMeshFileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstanceMeshFileBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id(&mut self, file_id: f64) {
    self.fbb_.push_slot::<f64>(InstanceMeshFile::VT_FILE_ID, file_id, 0.0);
  }
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMeshFile::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMeshFile::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn add_normals(&mut self, normals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMeshFile::VT_NORMALS, normals);
  }
  #[inline]
  pub fn add_instances(&mut self, instances: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InstanceMesh<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstanceMeshFile::VT_INSTANCES, instances);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstanceMeshFileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstanceMeshFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InstanceMeshFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SectorGeometryOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SectorGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SectorGeometry<'a> {
    type Inner = SectorGeometry<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SectorGeometry<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SectorGeometry {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SectorGeometryArgs<'args>) -> flatbuffers::WIPOffset<SectorGeometry<'bldr>> {
      let mut builder = SectorGeometryBuilder::new(_fbb);
      if let Some(x) = args.triangle_meshes { builder.add_triangle_meshes(x); }
      if let Some(x) = args.instance_meshes { builder.add_instance_meshes(x); }
      builder.finish()
    }

    pub const VT_INSTANCE_MESHES: flatbuffers::VOffsetT = 4;
    pub const VT_TRIANGLE_MESHES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn instance_meshes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstanceMeshFile<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InstanceMeshFile<'a>>>>>(SectorGeometry::VT_INSTANCE_MESHES, None)
  }
  #[inline]
  pub fn triangle_meshes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TriangleMesh<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TriangleMesh<'a>>>>>(SectorGeometry::VT_TRIANGLE_MESHES, None)
  }
}

pub struct SectorGeometryArgs<'a> {
    pub instance_meshes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InstanceMeshFile<'a >>>>>,
    pub triangle_meshes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<TriangleMesh<'a >>>>>,
}
impl<'a> Default for SectorGeometryArgs<'a> {
    #[inline]
    fn default() -> Self {
        SectorGeometryArgs {
            instance_meshes: None,
            triangle_meshes: None,
        }
    }
}
pub struct SectorGeometryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SectorGeometryBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance_meshes(&mut self, instance_meshes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InstanceMeshFile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectorGeometry::VT_INSTANCE_MESHES, instance_meshes);
  }
  #[inline]
  pub fn add_triangle_meshes(&mut self, triangle_meshes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TriangleMesh<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SectorGeometry::VT_TRIANGLE_MESHES, triangle_meshes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SectorGeometryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SectorGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SectorGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod DetailedSector

